// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: main.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Main.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - ZCSMainRoot

@implementation ZCSMainRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - ZCSMainRoot_FileDescriptor

static GPBFileDescriptor *ZCSMainRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"clickstream"
                                                 objcPrefix:@"ZCS"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Enum ZCSApp

GPBEnumDescriptor *ZCSApp_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Openplay\000Web\000Featurephone\000Fonoteka\000";
    static const int32_t values[] = {
        ZCSApp_Openplay,
        ZCSApp_Web,
        ZCSApp_Featurephone,
        ZCSApp_Fonoteka,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSApp)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSApp_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSApp_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSApp_Openplay:
    case ZCSApp_Web:
    case ZCSApp_Featurephone:
    case ZCSApp_Fonoteka:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ZCSOperatingSystem

GPBEnumDescriptor *ZCSOperatingSystem_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ios\000Android\000Desktop\000";
    static const int32_t values[] = {
        ZCSOperatingSystem_Ios,
        ZCSOperatingSystem_Android,
        ZCSOperatingSystem_Desktop,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSOperatingSystem)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSOperatingSystem_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSOperatingSystem_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSOperatingSystem_Ios:
    case ZCSOperatingSystem_Android:
    case ZCSOperatingSystem_Desktop:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ZCSSrcType

GPBEnumDescriptor *ZCSSrcType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Track\000Playlist\000Release\000Artist\000";
    static const int32_t values[] = {
        ZCSSrcType_Track,
        ZCSSrcType_Playlist,
        ZCSSrcType_Release,
        ZCSSrcType_Artist,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSSrcType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSSrcType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSSrcType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSSrcType_Track:
    case ZCSSrcType_Playlist:
    case ZCSSrcType_Release:
    case ZCSSrcType_Artist:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ZCSSrcChannel

GPBEnumDescriptor *ZCSSrcChannel_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "General\000Collection\000";
    static const int32_t values[] = {
        ZCSSrcChannel_General,
        ZCSSrcChannel_Collection,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSSrcChannel)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSSrcChannel_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSSrcChannel_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSSrcChannel_General:
    case ZCSSrcChannel_Collection:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ZCSItemType

GPBEnumDescriptor *ZCSItemType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "ItemTrack\000ItemPlaylist\000ItemRelease\000ItemA"
        "rtist\000ItemContentBlock\000ItemHistorySessio"
        "n\000ItemSearchRequest\000";
    static const int32_t values[] = {
        ZCSItemType_ItemTrack,
        ZCSItemType_ItemPlaylist,
        ZCSItemType_ItemRelease,
        ZCSItemType_ItemArtist,
        ZCSItemType_ItemContentBlock,
        ZCSItemType_ItemHistorySession,
        ZCSItemType_ItemSearchRequest,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSItemType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSItemType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSItemType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSItemType_ItemTrack:
    case ZCSItemType_ItemPlaylist:
    case ZCSItemType_ItemRelease:
    case ZCSItemType_ItemArtist:
    case ZCSItemType_ItemContentBlock:
    case ZCSItemType_ItemHistorySession:
    case ZCSItemType_ItemSearchRequest:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ZCSSource

GPBEnumDescriptor *ZCSSource_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Fb\000Vk\000Email\000Phone\000Other\000Google\000";
    static const int32_t values[] = {
        ZCSSource_Fb,
        ZCSSource_Vk,
        ZCSSource_Email,
        ZCSSource_Phone,
        ZCSSource_Other,
        ZCSSource_Google,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSSource)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSSource_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSSource_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSSource_Fb:
    case ZCSSource_Vk:
    case ZCSSource_Email:
    case ZCSSource_Phone:
    case ZCSSource_Other:
    case ZCSSource_Google:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ZCSSubscriptionType

GPBEnumDescriptor *ZCSSubscriptionType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Premium\000Trial\000Sponsor\000Freemium\000Unregiste"
        "red\000";
    static const int32_t values[] = {
        ZCSSubscriptionType_Premium,
        ZCSSubscriptionType_Trial,
        ZCSSubscriptionType_Sponsor,
        ZCSSubscriptionType_Freemium,
        ZCSSubscriptionType_Unregistered,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSSubscriptionType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSSubscriptionType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSSubscriptionType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSSubscriptionType_Premium:
    case ZCSSubscriptionType_Trial:
    case ZCSSubscriptionType_Sponsor:
    case ZCSSubscriptionType_Freemium:
    case ZCSSubscriptionType_Unregistered:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ZCSContentBlockType

GPBEnumDescriptor *ZCSContentBlockType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Content\000Situations\000Carousel\000ClientBlock\000"
        "Banner\000Recommender\000";
    static const int32_t values[] = {
        ZCSContentBlockType_Content,
        ZCSContentBlockType_Situations,
        ZCSContentBlockType_Carousel,
        ZCSContentBlockType_ClientBlock,
        ZCSContentBlockType_Banner,
        ZCSContentBlockType_Recommender,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSContentBlockType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSContentBlockType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSContentBlockType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSContentBlockType_Content:
    case ZCSContentBlockType_Situations:
    case ZCSContentBlockType_Carousel:
    case ZCSContentBlockType_ClientBlock:
    case ZCSContentBlockType_Banner:
    case ZCSContentBlockType_Recommender:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ZCSPlayAction

GPBEnumDescriptor *ZCSPlayAction_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Play\000Pause\000";
    static const int32_t values[] = {
        ZCSPlayAction_Play,
        ZCSPlayAction_Pause,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSPlayAction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSPlayAction_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSPlayAction_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSPlayAction_Play:
    case ZCSPlayAction_Pause:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ZCSOnOff

GPBEnumDescriptor *ZCSOnOff_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "On\000Off\000";
    static const int32_t values[] = {
        ZCSOnOff_On,
        ZCSOnOff_Off,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSOnOff)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSOnOff_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSOnOff_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSOnOff_On:
    case ZCSOnOff_Off:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ZCSContextOpenplay

@implementation ZCSContextOpenplay

@dynamic hasTimestamp, timestamp;
@dynamic hasTimezone, timezone;
@dynamic hasAppInstance, appInstance;
@dynamic hasUserId, userId;
@dynamic hasScreenWidth, screenWidth;
@dynamic hasScreenHeight, screenHeight;
@dynamic hasApp, app;
@dynamic hasConnectionType, connectionType;
@dynamic hasAppRelease, appRelease;
@dynamic hasOsVersion, osVersion;
@dynamic hasCarrierMcc, carrierMcc;
@dynamic hasCarrierMnc, carrierMnc;
@dynamic hasModel, model;
@dynamic hasOs, os;
@dynamic hasManufacturer, manufacturer;
@dynamic hasSubscriptionType, subscriptionType;
@dynamic hasSubscriptionName, subscriptionName;
@dynamic hasScreenType, screenType;
@dynamic hasScreenName, screenName;
@dynamic hasScreenNameMeta, screenNameMeta;
@dynamic hasScreenSection, screenSection;
@dynamic hasSessionId, sessionId;
@dynamic hasSessionNumber, sessionNumber;
@dynamic hasIsBackground, isBackground;

typedef struct ZCSContextOpenplay__storage_ {
  uint32_t _has_storage_[1];
  uint32_t screenWidth;
  uint32_t screenHeight;
  ZCSApp app;
  ZCSContextOpenplay_ConnectionType connectionType;
  ZCSOperatingSystem os;
  ZCSSubscriptionType subscriptionType;
  ZCSContextOpenplay_ScreenType screenType;
  ZCSContextOpenplay_ScreenSection screenSection;
  uint32_t sessionNumber;
  NSString *timestamp;
  NSString *timezone;
  NSString *appInstance;
  NSString *userId;
  NSString *appRelease;
  NSString *osVersion;
  NSString *carrierMcc;
  NSString *carrierMnc;
  NSString *model;
  NSString *manufacturer;
  NSString *subscriptionName;
  NSString *screenName;
  NSString *screenNameMeta;
  NSString *sessionId;
} ZCSContextOpenplay__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "timestamp",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextOpenplay_FieldNumber_Timestamp,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSContextOpenplay__storage_, timestamp),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "timezone",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextOpenplay_FieldNumber_Timezone,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSContextOpenplay__storage_, timezone),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "appInstance",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextOpenplay_FieldNumber_AppInstance,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ZCSContextOpenplay__storage_, appInstance),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "userId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextOpenplay_FieldNumber_UserId,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ZCSContextOpenplay__storage_, userId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "screenWidth",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextOpenplay_FieldNumber_ScreenWidth,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(ZCSContextOpenplay__storage_, screenWidth),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "screenHeight",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextOpenplay_FieldNumber_ScreenHeight,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(ZCSContextOpenplay__storage_, screenHeight),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = ZCSApp_Openplay,
        .core.name = "app",
        .core.dataTypeSpecific.enumDescFunc = ZCSApp_EnumDescriptor,
        .core.number = ZCSContextOpenplay_FieldNumber_App,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(ZCSContextOpenplay__storage_, app),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = ZCSContextOpenplay_ConnectionType_Network2G,
        .core.name = "connectionType",
        .core.dataTypeSpecific.enumDescFunc = ZCSContextOpenplay_ConnectionType_EnumDescriptor,
        .core.number = ZCSContextOpenplay_FieldNumber_ConnectionType,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(ZCSContextOpenplay__storage_, connectionType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "appRelease",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextOpenplay_FieldNumber_AppRelease,
        .core.hasIndex = 8,
        .core.offset = (uint32_t)offsetof(ZCSContextOpenplay__storage_, appRelease),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "osVersion",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextOpenplay_FieldNumber_OsVersion,
        .core.hasIndex = 9,
        .core.offset = (uint32_t)offsetof(ZCSContextOpenplay__storage_, osVersion),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "carrierMcc",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextOpenplay_FieldNumber_CarrierMcc,
        .core.hasIndex = 10,
        .core.offset = (uint32_t)offsetof(ZCSContextOpenplay__storage_, carrierMcc),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "carrierMnc",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextOpenplay_FieldNumber_CarrierMnc,
        .core.hasIndex = 11,
        .core.offset = (uint32_t)offsetof(ZCSContextOpenplay__storage_, carrierMnc),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "model",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextOpenplay_FieldNumber_Model,
        .core.hasIndex = 12,
        .core.offset = (uint32_t)offsetof(ZCSContextOpenplay__storage_, model),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = ZCSOperatingSystem_Ios,
        .core.name = "os",
        .core.dataTypeSpecific.enumDescFunc = ZCSOperatingSystem_EnumDescriptor,
        .core.number = ZCSContextOpenplay_FieldNumber_Os,
        .core.hasIndex = 13,
        .core.offset = (uint32_t)offsetof(ZCSContextOpenplay__storage_, os),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "manufacturer",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextOpenplay_FieldNumber_Manufacturer,
        .core.hasIndex = 14,
        .core.offset = (uint32_t)offsetof(ZCSContextOpenplay__storage_, manufacturer),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = ZCSSubscriptionType_Premium,
        .core.name = "subscriptionType",
        .core.dataTypeSpecific.enumDescFunc = ZCSSubscriptionType_EnumDescriptor,
        .core.number = ZCSContextOpenplay_FieldNumber_SubscriptionType,
        .core.hasIndex = 15,
        .core.offset = (uint32_t)offsetof(ZCSContextOpenplay__storage_, subscriptionType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "subscriptionName",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextOpenplay_FieldNumber_SubscriptionName,
        .core.hasIndex = 16,
        .core.offset = (uint32_t)offsetof(ZCSContextOpenplay__storage_, subscriptionName),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = ZCSContextOpenplay_ScreenType_UnknownScreen,
        .core.name = "screenType",
        .core.dataTypeSpecific.enumDescFunc = ZCSContextOpenplay_ScreenType_EnumDescriptor,
        .core.number = ZCSContextOpenplay_FieldNumber_ScreenType,
        .core.hasIndex = 17,
        .core.offset = (uint32_t)offsetof(ZCSContextOpenplay__storage_, screenType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "screenName",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextOpenplay_FieldNumber_ScreenName,
        .core.hasIndex = 18,
        .core.offset = (uint32_t)offsetof(ZCSContextOpenplay__storage_, screenName),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "screenNameMeta",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextOpenplay_FieldNumber_ScreenNameMeta,
        .core.hasIndex = 19,
        .core.offset = (uint32_t)offsetof(ZCSContextOpenplay__storage_, screenNameMeta),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = ZCSContextOpenplay_ScreenSection_All,
        .core.name = "screenSection",
        .core.dataTypeSpecific.enumDescFunc = ZCSContextOpenplay_ScreenSection_EnumDescriptor,
        .core.number = ZCSContextOpenplay_FieldNumber_ScreenSection,
        .core.hasIndex = 20,
        .core.offset = (uint32_t)offsetof(ZCSContextOpenplay__storage_, screenSection),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextOpenplay_FieldNumber_SessionId,
        .core.hasIndex = 21,
        .core.offset = (uint32_t)offsetof(ZCSContextOpenplay__storage_, sessionId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "sessionNumber",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextOpenplay_FieldNumber_SessionNumber,
        .core.hasIndex = 22,
        .core.offset = (uint32_t)offsetof(ZCSContextOpenplay__storage_, sessionNumber),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "isBackground",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextOpenplay_FieldNumber_IsBackground,
        .core.hasIndex = 23,
        .core.offset = 24,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSContextOpenplay class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSContextOpenplay__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ZCSContextOpenplay_ConnectionType

GPBEnumDescriptor *ZCSContextOpenplay_ConnectionType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Network2G\000Network3G\000Network4G\000Wifi\000Unkno"
        "wnConnection\000";
    static const int32_t values[] = {
        ZCSContextOpenplay_ConnectionType_Network2G,
        ZCSContextOpenplay_ConnectionType_Network3G,
        ZCSContextOpenplay_ConnectionType_Network4G,
        ZCSContextOpenplay_ConnectionType_Wifi,
        ZCSContextOpenplay_ConnectionType_UnknownConnection,
    };
    static const char *extraTextFormatInfo = "\003\000g\202\000\001g\202\000\002g\202\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSContextOpenplay_ConnectionType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSContextOpenplay_ConnectionType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSContextOpenplay_ConnectionType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSContextOpenplay_ConnectionType_Network2G:
    case ZCSContextOpenplay_ConnectionType_Network3G:
    case ZCSContextOpenplay_ConnectionType_Network4G:
    case ZCSContextOpenplay_ConnectionType_Wifi:
    case ZCSContextOpenplay_ConnectionType_UnknownConnection:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ZCSContextOpenplay_ScreenType

GPBEnumDescriptor *ZCSContextOpenplay_ScreenType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "UnknownScreen\000MainPage\000Popular\000Moods\000Pla"
        "yer\000PlayerHistory\000ContentBlock\000Artist\000Pl"
        "aylist\000Release\000Profile\000Collection\000Search"
        "\000SponsorScreen\000Subscriptions\000Other\000Grid\000"
        "Lyrics\000";
    static const int32_t values[] = {
        ZCSContextOpenplay_ScreenType_UnknownScreen,
        ZCSContextOpenplay_ScreenType_MainPage,
        ZCSContextOpenplay_ScreenType_Popular,
        ZCSContextOpenplay_ScreenType_Moods,
        ZCSContextOpenplay_ScreenType_Player,
        ZCSContextOpenplay_ScreenType_PlayerHistory,
        ZCSContextOpenplay_ScreenType_ContentBlock,
        ZCSContextOpenplay_ScreenType_Artist,
        ZCSContextOpenplay_ScreenType_Playlist,
        ZCSContextOpenplay_ScreenType_Release,
        ZCSContextOpenplay_ScreenType_Profile,
        ZCSContextOpenplay_ScreenType_Collection,
        ZCSContextOpenplay_ScreenType_Search,
        ZCSContextOpenplay_ScreenType_SponsorScreen,
        ZCSContextOpenplay_ScreenType_Subscriptions,
        ZCSContextOpenplay_ScreenType_Other,
        ZCSContextOpenplay_ScreenType_Grid,
        ZCSContextOpenplay_ScreenType_Lyrics,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSContextOpenplay_ScreenType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSContextOpenplay_ScreenType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSContextOpenplay_ScreenType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSContextOpenplay_ScreenType_UnknownScreen:
    case ZCSContextOpenplay_ScreenType_MainPage:
    case ZCSContextOpenplay_ScreenType_Popular:
    case ZCSContextOpenplay_ScreenType_Moods:
    case ZCSContextOpenplay_ScreenType_Player:
    case ZCSContextOpenplay_ScreenType_PlayerHistory:
    case ZCSContextOpenplay_ScreenType_ContentBlock:
    case ZCSContextOpenplay_ScreenType_Artist:
    case ZCSContextOpenplay_ScreenType_Playlist:
    case ZCSContextOpenplay_ScreenType_Release:
    case ZCSContextOpenplay_ScreenType_Profile:
    case ZCSContextOpenplay_ScreenType_Collection:
    case ZCSContextOpenplay_ScreenType_Search:
    case ZCSContextOpenplay_ScreenType_SponsorScreen:
    case ZCSContextOpenplay_ScreenType_Subscriptions:
    case ZCSContextOpenplay_ScreenType_Other:
    case ZCSContextOpenplay_ScreenType_Grid:
    case ZCSContextOpenplay_ScreenType_Lyrics:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ZCSContextOpenplay_ScreenSection

GPBEnumDescriptor *ZCSContextOpenplay_ScreenSection_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "All\000InCollection\000";
    static const int32_t values[] = {
        ZCSContextOpenplay_ScreenSection_All,
        ZCSContextOpenplay_ScreenSection_InCollection,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSContextOpenplay_ScreenSection)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSContextOpenplay_ScreenSection_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSContextOpenplay_ScreenSection_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSContextOpenplay_ScreenSection_All:
    case ZCSContextOpenplay_ScreenSection_InCollection:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ZCSContextWeb

@implementation ZCSContextWeb

@dynamic hasTimestamp, timestamp;
@dynamic hasTimezone, timezone;
@dynamic hasUserCookie, userCookie;
@dynamic hasUserAgent, userAgent;
@dynamic hasUserId, userId;
@dynamic hasScreenWidth, screenWidth;
@dynamic hasScreenHeight, screenHeight;
@dynamic hasApp, app;
@dynamic hasPageURL, pageURL;
@dynamic hasSubscriptionType, subscriptionType;
@dynamic hasSubscriptionName, subscriptionName;
@dynamic hasRefererURL, refererURL;
@dynamic hasUtmTags, utmTags;
@dynamic hasMousePosX, mousePosX;
@dynamic hasMousePosY, mousePosY;
@dynamic hasIsEmbedded, isEmbedded;

typedef struct ZCSContextWeb__storage_ {
  uint32_t _has_storage_[1];
  uint32_t screenWidth;
  uint32_t screenHeight;
  ZCSApp app;
  ZCSSubscriptionType subscriptionType;
  uint32_t mousePosX;
  uint32_t mousePosY;
  NSString *timestamp;
  NSString *timezone;
  NSString *userCookie;
  NSString *userAgent;
  NSString *userId;
  NSString *pageURL;
  NSString *subscriptionName;
  NSString *refererURL;
  NSString *utmTags;
} ZCSContextWeb__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "timestamp",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextWeb_FieldNumber_Timestamp,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSContextWeb__storage_, timestamp),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "timezone",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextWeb_FieldNumber_Timezone,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSContextWeb__storage_, timezone),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "userCookie",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextWeb_FieldNumber_UserCookie,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ZCSContextWeb__storage_, userCookie),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "userAgent",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextWeb_FieldNumber_UserAgent,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ZCSContextWeb__storage_, userAgent),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "userId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextWeb_FieldNumber_UserId,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(ZCSContextWeb__storage_, userId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "screenWidth",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextWeb_FieldNumber_ScreenWidth,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(ZCSContextWeb__storage_, screenWidth),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "screenHeight",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextWeb_FieldNumber_ScreenHeight,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(ZCSContextWeb__storage_, screenHeight),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = ZCSApp_Openplay,
        .core.name = "app",
        .core.dataTypeSpecific.enumDescFunc = ZCSApp_EnumDescriptor,
        .core.number = ZCSContextWeb_FieldNumber_App,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(ZCSContextWeb__storage_, app),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "pageURL",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextWeb_FieldNumber_PageURL,
        .core.hasIndex = 8,
        .core.offset = (uint32_t)offsetof(ZCSContextWeb__storage_, pageURL),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = ZCSSubscriptionType_Premium,
        .core.name = "subscriptionType",
        .core.dataTypeSpecific.enumDescFunc = ZCSSubscriptionType_EnumDescriptor,
        .core.number = ZCSContextWeb_FieldNumber_SubscriptionType,
        .core.hasIndex = 9,
        .core.offset = (uint32_t)offsetof(ZCSContextWeb__storage_, subscriptionType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "subscriptionName",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextWeb_FieldNumber_SubscriptionName,
        .core.hasIndex = 10,
        .core.offset = (uint32_t)offsetof(ZCSContextWeb__storage_, subscriptionName),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "refererURL",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextWeb_FieldNumber_RefererURL,
        .core.hasIndex = 11,
        .core.offset = (uint32_t)offsetof(ZCSContextWeb__storage_, refererURL),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "utmTags",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextWeb_FieldNumber_UtmTags,
        .core.hasIndex = 12,
        .core.offset = (uint32_t)offsetof(ZCSContextWeb__storage_, utmTags),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "mousePosX",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextWeb_FieldNumber_MousePosX,
        .core.hasIndex = 13,
        .core.offset = (uint32_t)offsetof(ZCSContextWeb__storage_, mousePosX),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "mousePosY",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextWeb_FieldNumber_MousePosY,
        .core.hasIndex = 14,
        .core.offset = (uint32_t)offsetof(ZCSContextWeb__storage_, mousePosY),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "isEmbedded",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContextWeb_FieldNumber_IsEmbedded,
        .core.hasIndex = 15,
        .core.offset = 16,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSContextWeb class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSContextWeb__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\t\004\241!!\000\014\007\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSPlayevent

@implementation ZCSPlayevent

@dynamic hasStartDate, startDate;
@dynamic hasAppInstance, appInstance;
@dynamic hasUserId, userId;
@dynamic hasTrackDuration, trackDuration;
@dynamic hasStopDate, stopDate;
@dynamic hasApp, app;
@dynamic hasStopPos, stopPos;
@dynamic hasPhoneType, phoneType;
@dynamic hasStopReason, stopReason;
@dynamic hasTrackId, trackId;
@dynamic hasTimezone, timezone;
@dynamic hasStartPos, startPos;
@dynamic hasStartReason, startReason;
@dynamic hasSrcType, srcType;
@dynamic hasSrcId, srcId;
@dynamic hasIsStream, isStream;
@dynamic hasDelay, delay;
@dynamic hasDelayPos, delayPos;
@dynamic hasContext, context;
@dynamic hasContentBlock, contentBlock;
@dynamic hasSrcChannel, srcChannel;

typedef struct ZCSPlayevent__storage_ {
  uint32_t _has_storage_[1];
  uint32_t trackDuration;
  ZCSApp app;
  uint32_t stopPos;
  ZCSOperatingSystem phoneType;
  ZCSPlayevent_StopReason stopReason;
  uint32_t trackId;
  int32_t timezone;
  uint32_t startPos;
  ZCSPlayevent_StartReason startReason;
  ZCSSrcType srcType;
  int32_t srcId;
  uint32_t delay;
  uint32_t delayPos;
  ZCSSrcChannel srcChannel;
  NSString *startDate;
  NSString *appInstance;
  NSString *userId;
  NSString *stopDate;
  ZCSContextOpenplay *context;
  ZCSContentBlock *contentBlock;
} ZCSPlayevent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "startDate",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSPlayevent_FieldNumber_StartDate,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSPlayevent__storage_, startDate),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "appInstance",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSPlayevent_FieldNumber_AppInstance,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSPlayevent__storage_, appInstance),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "userId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSPlayevent_FieldNumber_UserId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ZCSPlayevent__storage_, userId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "trackDuration",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSPlayevent_FieldNumber_TrackDuration,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ZCSPlayevent__storage_, trackDuration),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "stopDate",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSPlayevent_FieldNumber_StopDate,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(ZCSPlayevent__storage_, stopDate),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = ZCSApp_Openplay,
        .core.name = "app",
        .core.dataTypeSpecific.enumDescFunc = ZCSApp_EnumDescriptor,
        .core.number = ZCSPlayevent_FieldNumber_App,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(ZCSPlayevent__storage_, app),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "stopPos",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSPlayevent_FieldNumber_StopPos,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(ZCSPlayevent__storage_, stopPos),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = ZCSOperatingSystem_Ios,
        .core.name = "phoneType",
        .core.dataTypeSpecific.enumDescFunc = ZCSOperatingSystem_EnumDescriptor,
        .core.number = ZCSPlayevent_FieldNumber_PhoneType,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(ZCSPlayevent__storage_, phoneType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = ZCSPlayevent_StopReason_StopStop,
        .core.name = "stopReason",
        .core.dataTypeSpecific.enumDescFunc = ZCSPlayevent_StopReason_EnumDescriptor,
        .core.number = ZCSPlayevent_FieldNumber_StopReason,
        .core.hasIndex = 8,
        .core.offset = (uint32_t)offsetof(ZCSPlayevent__storage_, stopReason),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "trackId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSPlayevent_FieldNumber_TrackId,
        .core.hasIndex = 9,
        .core.offset = (uint32_t)offsetof(ZCSPlayevent__storage_, trackId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "timezone",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSPlayevent_FieldNumber_Timezone,
        .core.hasIndex = 10,
        .core.offset = (uint32_t)offsetof(ZCSPlayevent__storage_, timezone),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "startPos",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSPlayevent_FieldNumber_StartPos,
        .core.hasIndex = 11,
        .core.offset = (uint32_t)offsetof(ZCSPlayevent__storage_, startPos),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueEnum = ZCSPlayevent_StartReason_StartResume,
        .core.name = "startReason",
        .core.dataTypeSpecific.enumDescFunc = ZCSPlayevent_StartReason_EnumDescriptor,
        .core.number = ZCSPlayevent_FieldNumber_StartReason,
        .core.hasIndex = 12,
        .core.offset = (uint32_t)offsetof(ZCSPlayevent__storage_, startReason),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = ZCSSrcType_Track,
        .core.name = "srcType",
        .core.dataTypeSpecific.enumDescFunc = ZCSSrcType_EnumDescriptor,
        .core.number = ZCSPlayevent_FieldNumber_SrcType,
        .core.hasIndex = 13,
        .core.offset = (uint32_t)offsetof(ZCSPlayevent__storage_, srcType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "srcId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSPlayevent_FieldNumber_SrcId,
        .core.hasIndex = 14,
        .core.offset = (uint32_t)offsetof(ZCSPlayevent__storage_, srcId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "isStream",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSPlayevent_FieldNumber_IsStream,
        .core.hasIndex = 15,
        .core.offset = 16,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "delay",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSPlayevent_FieldNumber_Delay,
        .core.hasIndex = 17,
        .core.offset = (uint32_t)offsetof(ZCSPlayevent__storage_, delay),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "delayPos",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSPlayevent_FieldNumber_DelayPos,
        .core.hasIndex = 18,
        .core.offset = (uint32_t)offsetof(ZCSPlayevent__storage_, delayPos),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSPlayevent_FieldNumber_Context,
        .core.hasIndex = 19,
        .core.offset = (uint32_t)offsetof(ZCSPlayevent__storage_, context),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "contentBlock",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContentBlock),
        .core.number = ZCSPlayevent_FieldNumber_ContentBlock,
        .core.hasIndex = 20,
        .core.offset = (uint32_t)offsetof(ZCSPlayevent__storage_, contentBlock),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSSrcChannel_General,
        .core.name = "srcChannel",
        .core.dataTypeSpecific.enumDescFunc = ZCSSrcChannel_EnumDescriptor,
        .core.number = ZCSPlayevent_FieldNumber_SrcChannel,
        .core.hasIndex = 21,
        .core.offset = (uint32_t)offsetof(ZCSPlayevent__storage_, srcChannel),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSPlayevent class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSPlayevent__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ZCSPlayevent_StopReason

GPBEnumDescriptor *ZCSPlayevent_StopReason_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "StopStop\000StopEnd\000StopPause\000StopError\000Sto"
        "pSeek\000StopNext\000StopPrev\000";
    static const int32_t values[] = {
        ZCSPlayevent_StopReason_StopStop,
        ZCSPlayevent_StopReason_StopEnd,
        ZCSPlayevent_StopReason_StopPause,
        ZCSPlayevent_StopReason_StopError,
        ZCSPlayevent_StopReason_StopSeek,
        ZCSPlayevent_StopReason_StopNext,
        ZCSPlayevent_StopReason_StopPrev,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSPlayevent_StopReason)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSPlayevent_StopReason_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSPlayevent_StopReason_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSPlayevent_StopReason_StopStop:
    case ZCSPlayevent_StopReason_StopEnd:
    case ZCSPlayevent_StopReason_StopPause:
    case ZCSPlayevent_StopReason_StopError:
    case ZCSPlayevent_StopReason_StopSeek:
    case ZCSPlayevent_StopReason_StopNext:
    case ZCSPlayevent_StopReason_StopPrev:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ZCSPlayevent_StartReason

GPBEnumDescriptor *ZCSPlayevent_StartReason_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "StartResume\000StartError\000StartSeek\000StartNe"
        "xt\000StartPrev\000StartPlay\000";
    static const int32_t values[] = {
        ZCSPlayevent_StartReason_StartResume,
        ZCSPlayevent_StartReason_StartError,
        ZCSPlayevent_StartReason_StartSeek,
        ZCSPlayevent_StartReason_StartNext,
        ZCSPlayevent_StartReason_StartPrev,
        ZCSPlayevent_StartReason_StartPlay,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSPlayevent_StartReason)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSPlayevent_StartReason_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSPlayevent_StartReason_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSPlayevent_StartReason_StartResume:
    case ZCSPlayevent_StartReason_StartError:
    case ZCSPlayevent_StartReason_StartSeek:
    case ZCSPlayevent_StartReason_StartNext:
    case ZCSPlayevent_StartReason_StartPrev:
    case ZCSPlayevent_StartReason_StartPlay:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ZCSAppOpened

@implementation ZCSAppOpened

@dynamic hasContext, context;
@dynamic hasFirstTime, firstTime;
@dynamic hasLoggedIn, loggedIn;

typedef struct ZCSAppOpened__storage_ {
  uint32_t _has_storage_[1];
  ZCSContextOpenplay *context;
} ZCSAppOpened__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .number = ZCSAppOpened_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZCSAppOpened__storage_, context),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "firstTime",
        .dataTypeSpecific.className = NULL,
        .number = ZCSAppOpened_FieldNumber_FirstTime,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "loggedIn",
        .dataTypeSpecific.className = NULL,
        .number = ZCSAppOpened_FieldNumber_LoggedIn,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSAppOpened class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZCSAppOpened__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSAppResume

@implementation ZCSAppResume

@dynamic hasContext, context;
@dynamic hasLoggedIn, loggedIn;

typedef struct ZCSAppResume__storage_ {
  uint32_t _has_storage_[1];
  ZCSContextOpenplay *context;
} ZCSAppResume__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .number = ZCSAppResume_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZCSAppResume__storage_, context),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "loggedIn",
        .dataTypeSpecific.className = NULL,
        .number = ZCSAppResume_FieldNumber_LoggedIn,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSAppResume class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZCSAppResume__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSAuthenticationInitiated

@implementation ZCSAuthenticationInitiated

@dynamic hasContext, context;
@dynamic hasSource, source;
@dynamic hasSourceName, sourceName;

typedef struct ZCSAuthenticationInitiated__storage_ {
  uint32_t _has_storage_[1];
  ZCSSource source;
  ZCSContextOpenplay *context;
  NSString *sourceName;
} ZCSAuthenticationInitiated__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSAuthenticationInitiated_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSAuthenticationInitiated__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSSource_Fb,
        .core.name = "source",
        .core.dataTypeSpecific.enumDescFunc = ZCSSource_EnumDescriptor,
        .core.number = ZCSAuthenticationInitiated_FieldNumber_Source,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSAuthenticationInitiated__storage_, source),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "sourceName",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSAuthenticationInitiated_FieldNumber_SourceName,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ZCSAuthenticationInitiated__storage_, sourceName),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSAuthenticationInitiated class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSAuthenticationInitiated__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSAuthenticationSuccessful

@implementation ZCSAuthenticationSuccessful

@dynamic hasContext, context;
@dynamic hasSource, source;
@dynamic hasType, type;
@dynamic hasSourceName, sourceName;

typedef struct ZCSAuthenticationSuccessful__storage_ {
  uint32_t _has_storage_[1];
  ZCSSource source;
  ZCSAuthenticationSuccessful_Type type;
  ZCSContextOpenplay *context;
  NSString *sourceName;
} ZCSAuthenticationSuccessful__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSAuthenticationSuccessful_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSAuthenticationSuccessful__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSSource_Fb,
        .core.name = "source",
        .core.dataTypeSpecific.enumDescFunc = ZCSSource_EnumDescriptor,
        .core.number = ZCSAuthenticationSuccessful_FieldNumber_Source,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSAuthenticationSuccessful__storage_, source),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = ZCSAuthenticationSuccessful_Type_Login,
        .core.name = "type",
        .core.dataTypeSpecific.enumDescFunc = ZCSAuthenticationSuccessful_Type_EnumDescriptor,
        .core.number = ZCSAuthenticationSuccessful_FieldNumber_Type,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ZCSAuthenticationSuccessful__storage_, type),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "sourceName",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSAuthenticationSuccessful_FieldNumber_SourceName,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ZCSAuthenticationSuccessful__storage_, sourceName),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSAuthenticationSuccessful class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSAuthenticationSuccessful__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ZCSAuthenticationSuccessful_Type

GPBEnumDescriptor *ZCSAuthenticationSuccessful_Type_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Login\000Registration\000";
    static const int32_t values[] = {
        ZCSAuthenticationSuccessful_Type_Login,
        ZCSAuthenticationSuccessful_Type_Registration,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSAuthenticationSuccessful_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSAuthenticationSuccessful_Type_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSAuthenticationSuccessful_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSAuthenticationSuccessful_Type_Login:
    case ZCSAuthenticationSuccessful_Type_Registration:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ZCSAuthenticationFailed

@implementation ZCSAuthenticationFailed

@dynamic hasContext, context;
@dynamic hasSource, source;
@dynamic hasReason, reason;
@dynamic hasSourceName, sourceName;

typedef struct ZCSAuthenticationFailed__storage_ {
  uint32_t _has_storage_[1];
  ZCSSource source;
  ZCSContextOpenplay *context;
  NSString *reason;
  NSString *sourceName;
} ZCSAuthenticationFailed__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSAuthenticationFailed_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSAuthenticationFailed__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSSource_Fb,
        .core.name = "source",
        .core.dataTypeSpecific.enumDescFunc = ZCSSource_EnumDescriptor,
        .core.number = ZCSAuthenticationFailed_FieldNumber_Source,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSAuthenticationFailed__storage_, source),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "reason",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSAuthenticationFailed_FieldNumber_Reason,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ZCSAuthenticationFailed__storage_, reason),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "sourceName",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSAuthenticationFailed_FieldNumber_SourceName,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ZCSAuthenticationFailed__storage_, sourceName),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSAuthenticationFailed class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSAuthenticationFailed__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSSubscriptionInitiated

@implementation ZCSSubscriptionInitiated

@dynamic hasContext, context;
@dynamic hasInitSubscriptionType, initSubscriptionType;
@dynamic hasIsRestore, isRestore;

typedef struct ZCSSubscriptionInitiated__storage_ {
  uint32_t _has_storage_[1];
  ZCSSubscriptionType initSubscriptionType;
  ZCSContextOpenplay *context;
} ZCSSubscriptionInitiated__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSSubscriptionInitiated_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSSubscriptionInitiated__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSSubscriptionType_Premium,
        .core.name = "initSubscriptionType",
        .core.dataTypeSpecific.enumDescFunc = ZCSSubscriptionType_EnumDescriptor,
        .core.number = ZCSSubscriptionInitiated_FieldNumber_InitSubscriptionType,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSSubscriptionInitiated__storage_, initSubscriptionType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "isRestore",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSSubscriptionInitiated_FieldNumber_IsRestore,
        .core.hasIndex = 2,
        .core.offset = 3,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSSubscriptionInitiated class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSSubscriptionInitiated__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSSubscriptionSuccessful

@implementation ZCSSubscriptionSuccessful

@dynamic hasContext, context;
@dynamic hasInitSubscriptionType, initSubscriptionType;
@dynamic hasInitSubscriptionName, initSubscriptionName;

typedef struct ZCSSubscriptionSuccessful__storage_ {
  uint32_t _has_storage_[1];
  ZCSSubscriptionType initSubscriptionType;
  ZCSContextOpenplay *context;
  NSString *initSubscriptionName;
} ZCSSubscriptionSuccessful__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSSubscriptionSuccessful_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSSubscriptionSuccessful__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSSubscriptionType_Premium,
        .core.name = "initSubscriptionType",
        .core.dataTypeSpecific.enumDescFunc = ZCSSubscriptionType_EnumDescriptor,
        .core.number = ZCSSubscriptionSuccessful_FieldNumber_InitSubscriptionType,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSSubscriptionSuccessful__storage_, initSubscriptionType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "initSubscriptionName",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSSubscriptionSuccessful_FieldNumber_InitSubscriptionName,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ZCSSubscriptionSuccessful__storage_, initSubscriptionName),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSSubscriptionSuccessful class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSSubscriptionSuccessful__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSSubscriptionFailed

@implementation ZCSSubscriptionFailed

@dynamic hasContext, context;
@dynamic hasInitSubscriptionType, initSubscriptionType;
@dynamic hasReason, reason;
@dynamic hasInitSubscriptionName, initSubscriptionName;

typedef struct ZCSSubscriptionFailed__storage_ {
  uint32_t _has_storage_[1];
  ZCSSubscriptionType initSubscriptionType;
  ZCSContextOpenplay *context;
  NSString *reason;
  NSString *initSubscriptionName;
} ZCSSubscriptionFailed__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSSubscriptionFailed_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSSubscriptionFailed__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSSubscriptionType_Premium,
        .core.name = "initSubscriptionType",
        .core.dataTypeSpecific.enumDescFunc = ZCSSubscriptionType_EnumDescriptor,
        .core.number = ZCSSubscriptionFailed_FieldNumber_InitSubscriptionType,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSSubscriptionFailed__storage_, initSubscriptionType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "reason",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSSubscriptionFailed_FieldNumber_Reason,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ZCSSubscriptionFailed__storage_, reason),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "initSubscriptionName",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSSubscriptionFailed_FieldNumber_InitSubscriptionName,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ZCSSubscriptionFailed__storage_, initSubscriptionName),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSSubscriptionFailed class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSSubscriptionFailed__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSActionKit

@implementation ZCSActionKit

@dynamic hasType, type;
@dynamic hasName, name;
@dynamic advItemArray, advItemArray_Count;
@dynamic hasContentProvider, contentProvider;
@dynamic actionKitItemArray, actionKitItemArray_Count;
@dynamic hasComment, comment;

typedef struct ZCSActionKit__storage_ {
  uint32_t _has_storage_[1];
  ZCSActionKit_Type type;
  NSString *name;
  NSMutableArray *advItemArray;
  NSString *contentProvider;
  NSMutableArray *actionKitItemArray;
  NSString *comment;
} ZCSActionKit__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = ZCSActionKit_Type_Banner,
        .core.name = "type",
        .core.dataTypeSpecific.enumDescFunc = ZCSActionKit_Type_EnumDescriptor,
        .core.number = ZCSActionKit_FieldNumber_Type,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSActionKit__storage_, type),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "name",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSActionKit_FieldNumber_Name,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSActionKit__storage_, name),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "advItemArray",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSAdvItem),
        .core.number = ZCSActionKit_FieldNumber_AdvItemArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(ZCSActionKit__storage_, advItemArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "contentProvider",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSActionKit_FieldNumber_ContentProvider,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ZCSActionKit__storage_, contentProvider),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "actionKitItemArray",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSActionKitItem),
        .core.number = ZCSActionKit_FieldNumber_ActionKitItemArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(ZCSActionKit__storage_, actionKitItemArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "comment",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSActionKit_FieldNumber_Comment,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ZCSActionKit__storage_, comment),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSActionKit class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSActionKit__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ZCSActionKit_Type

GPBEnumDescriptor *ZCSActionKit_Type_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Banner\000Popup\000BrandedPlaylist\000ActionMenu\000"
        "Clip\000";
    static const int32_t values[] = {
        ZCSActionKit_Type_Banner,
        ZCSActionKit_Type_Popup,
        ZCSActionKit_Type_BrandedPlaylist,
        ZCSActionKit_Type_ActionMenu,
        ZCSActionKit_Type_Clip,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSActionKit_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSActionKit_Type_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSActionKit_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSActionKit_Type_Banner:
    case ZCSActionKit_Type_Popup:
    case ZCSActionKit_Type_BrandedPlaylist:
    case ZCSActionKit_Type_ActionMenu:
    case ZCSActionKit_Type_Clip:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ZCSActionKitShown

@implementation ZCSActionKitShown

@dynamic hasContext, context;
@dynamic hasActionKit, actionKit;

typedef struct ZCSActionKitShown__storage_ {
  uint32_t _has_storage_[1];
  ZCSContextOpenplay *context;
  ZCSActionKit *actionKit;
} ZCSActionKitShown__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .number = ZCSActionKitShown_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZCSActionKitShown__storage_, context),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "actionKit",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSActionKit),
        .number = ZCSActionKitShown_FieldNumber_ActionKit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZCSActionKitShown__storage_, actionKit),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSActionKitShown class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZCSActionKitShown__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSActionKitClicked

@implementation ZCSActionKitClicked

@dynamic hasContext, context;
@dynamic hasActionKit, actionKit;

typedef struct ZCSActionKitClicked__storage_ {
  uint32_t _has_storage_[1];
  ZCSContextOpenplay *context;
  ZCSActionKit *actionKit;
} ZCSActionKitClicked__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .number = ZCSActionKitClicked_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZCSActionKitClicked__storage_, context),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "actionKit",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSActionKit),
        .number = ZCSActionKitClicked_FieldNumber_ActionKit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZCSActionKitClicked__storage_, actionKit),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSActionKitClicked class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZCSActionKitClicked__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSActionKitRequested

@implementation ZCSActionKitRequested

@dynamic hasContext, context;
@dynamic hasActionKit, actionKit;

typedef struct ZCSActionKitRequested__storage_ {
  uint32_t _has_storage_[1];
  ZCSContextOpenplay *context;
  ZCSActionKit *actionKit;
} ZCSActionKitRequested__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .number = ZCSActionKitRequested_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZCSActionKitRequested__storage_, context),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "actionKit",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSActionKit),
        .number = ZCSActionKitRequested_FieldNumber_ActionKit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZCSActionKitRequested__storage_, actionKit),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSActionKitRequested class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZCSActionKitRequested__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSActionKitLoaded

@implementation ZCSActionKitLoaded

@dynamic hasContext, context;
@dynamic hasActionKit, actionKit;

typedef struct ZCSActionKitLoaded__storage_ {
  uint32_t _has_storage_[1];
  ZCSContextOpenplay *context;
  ZCSActionKit *actionKit;
} ZCSActionKitLoaded__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .number = ZCSActionKitLoaded_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZCSActionKitLoaded__storage_, context),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "actionKit",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSActionKit),
        .number = ZCSActionKitLoaded_FieldNumber_ActionKit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZCSActionKitLoaded__storage_, actionKit),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSActionKitLoaded class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZCSActionKitLoaded__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSContentBlock

@implementation ZCSContentBlock

@dynamic hasType, type;
@dynamic hasHeader, header;
@dynamic hasHeaderMeta, headerMeta;
@dynamic hasPosition, position;
@dynamic itemArray, itemArray_Count;

typedef struct ZCSContentBlock__storage_ {
  uint32_t _has_storage_[1];
  ZCSContentBlockType type;
  uint32_t position;
  NSString *header;
  NSString *headerMeta;
  NSMutableArray *itemArray;
} ZCSContentBlock__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = ZCSContentBlockType_Content,
        .core.name = "type",
        .core.dataTypeSpecific.enumDescFunc = ZCSContentBlockType_EnumDescriptor,
        .core.number = ZCSContentBlock_FieldNumber_Type,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSContentBlock__storage_, type),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "header",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContentBlock_FieldNumber_Header,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSContentBlock__storage_, header),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "headerMeta",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContentBlock_FieldNumber_HeaderMeta,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ZCSContentBlock__storage_, headerMeta),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "position",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSContentBlock_FieldNumber_Position,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ZCSContentBlock__storage_, position),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "itemArray",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSItem),
        .core.number = ZCSContentBlock_FieldNumber_ItemArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(ZCSContentBlock__storage_, itemArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSContentBlock class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSContentBlock__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSActionKitItem

@implementation ZCSActionKitItem

@dynamic hasType, type;
@dynamic hasHeader, header;
@dynamic hasBody, body;
@dynamic hasActionKitSource, actionKitSource;
@dynamic hasActionKitLink, actionKitLink;

typedef struct ZCSActionKitItem__storage_ {
  uint32_t _has_storage_[1];
  ZCSActionKitItem_Type type;
  NSString *header;
  NSString *body;
  NSString *actionKitSource;
  NSString *actionKitLink;
} ZCSActionKitItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = ZCSActionKitItem_Type_Banner,
        .core.name = "type",
        .core.dataTypeSpecific.enumDescFunc = ZCSActionKitItem_Type_EnumDescriptor,
        .core.number = ZCSActionKitItem_FieldNumber_Type,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSActionKitItem__storage_, type),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "header",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSActionKitItem_FieldNumber_Header,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSActionKitItem__storage_, header),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "body",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSActionKitItem_FieldNumber_Body,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ZCSActionKitItem__storage_, body),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "actionKitSource",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSActionKitItem_FieldNumber_ActionKitSource,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ZCSActionKitItem__storage_, actionKitSource),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "actionKitLink",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSActionKitItem_FieldNumber_ActionKitLink,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(ZCSActionKitItem__storage_, actionKitLink),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSActionKitItem class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSActionKitItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ZCSActionKitItem_Type

GPBEnumDescriptor *ZCSActionKitItem_Type_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Banner\000Button\000Audio\000";
    static const int32_t values[] = {
        ZCSActionKitItem_Type_Banner,
        ZCSActionKitItem_Type_Button,
        ZCSActionKitItem_Type_Audio,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSActionKitItem_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSActionKitItem_Type_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSActionKitItem_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSActionKitItem_Type_Banner:
    case ZCSActionKitItem_Type_Button:
    case ZCSActionKitItem_Type_Audio:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ZCSAdvItem

@implementation ZCSAdvItem

@dynamic hasType, type;
@dynamic hasHeader, header;
@dynamic hasBody, body;
@dynamic hasImgSource, imgSource;
@dynamic hasDestinationURL, destinationURL;
@dynamic hasSrcType, srcType;
@dynamic hasSrcId, srcId;

typedef struct ZCSAdvItem__storage_ {
  uint32_t _has_storage_[1];
  ZCSAdvItem_Type type;
  ZCSSrcType srcType;
  NSString *header;
  NSString *body;
  NSString *imgSource;
  NSString *destinationURL;
  NSString *srcId;
} ZCSAdvItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = ZCSAdvItem_Type_Banner,
        .core.name = "type",
        .core.dataTypeSpecific.enumDescFunc = ZCSAdvItem_Type_EnumDescriptor,
        .core.number = ZCSAdvItem_FieldNumber_Type,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSAdvItem__storage_, type),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "header",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSAdvItem_FieldNumber_Header,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSAdvItem__storage_, header),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "body",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSAdvItem_FieldNumber_Body,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ZCSAdvItem__storage_, body),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "imgSource",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSAdvItem_FieldNumber_ImgSource,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ZCSAdvItem__storage_, imgSource),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "destinationURL",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSAdvItem_FieldNumber_DestinationURL,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(ZCSAdvItem__storage_, destinationURL),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = ZCSSrcType_Track,
        .core.name = "srcType",
        .core.dataTypeSpecific.enumDescFunc = ZCSSrcType_EnumDescriptor,
        .core.number = ZCSAdvItem_FieldNumber_SrcType,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(ZCSAdvItem__storage_, srcType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "srcId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSAdvItem_FieldNumber_SrcId,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(ZCSAdvItem__storage_, srcId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSAdvItem class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSAdvItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\005\013\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ZCSAdvItem_Type

GPBEnumDescriptor *ZCSAdvItem_Type_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Banner\000Button\000";
    static const int32_t values[] = {
        ZCSAdvItem_Type_Banner,
        ZCSAdvItem_Type_Button,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSAdvItem_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSAdvItem_Type_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSAdvItem_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSAdvItem_Type_Banner:
    case ZCSAdvItem_Type_Button:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ZCSItem

@implementation ZCSItem

@dynamic hasItemType, itemType;
@dynamic hasFeatured, featured;
@dynamic hasPosition, position;
@dynamic hasSrcId, srcId;
@dynamic hasDestinationURL, destinationURL;
@dynamic hasHeader, header;

typedef struct ZCSItem__storage_ {
  uint32_t _has_storage_[1];
  ZCSItemType itemType;
  uint32_t position;
  NSString *srcId;
  NSString *destinationURL;
  NSString *header;
} ZCSItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = ZCSItemType_ItemTrack,
        .core.name = "itemType",
        .core.dataTypeSpecific.enumDescFunc = ZCSItemType_EnumDescriptor,
        .core.number = ZCSItem_FieldNumber_ItemType,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSItem__storage_, itemType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "featured",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSItem_FieldNumber_Featured,
        .core.hasIndex = 1,
        .core.offset = 2,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "position",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSItem_FieldNumber_Position,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ZCSItem__storage_, position),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "srcId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSItem_FieldNumber_SrcId,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(ZCSItem__storage_, srcId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "destinationURL",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSItem_FieldNumber_DestinationURL,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(ZCSItem__storage_, destinationURL),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "header",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSItem_FieldNumber_Header,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(ZCSItem__storage_, header),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSItem class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\005\013\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSScreenShown

@implementation ZCSScreenShown

@dynamic hasContext, context;
@dynamic contentBlockArray, contentBlockArray_Count;
@dynamic hasPageNumber, pageNumber;

typedef struct ZCSScreenShown__storage_ {
  uint32_t _has_storage_[1];
  uint32_t pageNumber;
  ZCSContextOpenplay *context;
  NSMutableArray *contentBlockArray;
} ZCSScreenShown__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .number = ZCSScreenShown_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZCSScreenShown__storage_, context),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contentBlockArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSContentBlock),
        .number = ZCSScreenShown_FieldNumber_ContentBlockArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZCSScreenShown__storage_, contentBlockArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pageNumber",
        .dataTypeSpecific.className = NULL,
        .number = ZCSScreenShown_FieldNumber_PageNumber,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZCSScreenShown__storage_, pageNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSScreenShown class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZCSScreenShown__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSContentBlockClick

@implementation ZCSContentBlockClick

@dynamic hasContext, context;
@dynamic hasContentBlock, contentBlock;
@dynamic hasAction, action;

typedef struct ZCSContentBlockClick__storage_ {
  uint32_t _has_storage_[1];
  ZCSContentBlockClick_Action action;
  ZCSContextOpenplay *context;
  ZCSContentBlock *contentBlock;
} ZCSContentBlockClick__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSContentBlockClick_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSContentBlockClick__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "contentBlock",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContentBlock),
        .core.number = ZCSContentBlockClick_FieldNumber_ContentBlock,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSContentBlockClick__storage_, contentBlock),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSContentBlockClick_Action_ItemPick,
        .core.name = "action",
        .core.dataTypeSpecific.enumDescFunc = ZCSContentBlockClick_Action_EnumDescriptor,
        .core.number = ZCSContentBlockClick_FieldNumber_Action,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ZCSContentBlockClick__storage_, action),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSContentBlockClick class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSContentBlockClick__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ZCSContentBlockClick_Action

GPBEnumDescriptor *ZCSContentBlockClick_Action_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "ItemPick\000Expand\000Close\000";
    static const int32_t values[] = {
        ZCSContentBlockClick_Action_ItemPick,
        ZCSContentBlockClick_Action_Expand,
        ZCSContentBlockClick_Action_Close,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSContentBlockClick_Action)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSContentBlockClick_Action_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSContentBlockClick_Action_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSContentBlockClick_Action_ItemPick:
    case ZCSContentBlockClick_Action_Expand:
    case ZCSContentBlockClick_Action_Close:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ZCSPlay

@implementation ZCSPlay

@dynamic hasContext, context;
@dynamic hasAction, action;
@dynamic hasItemType, itemType;
@dynamic hasSrcId, srcId;
@dynamic hasTrackId, trackId;
@dynamic hasContentBlock, contentBlock;

typedef struct ZCSPlay__storage_ {
  uint32_t _has_storage_[1];
  ZCSPlayAction action;
  ZCSItemType itemType;
  ZCSContextOpenplay *context;
  NSString *srcId;
  NSString *trackId;
  ZCSContentBlock *contentBlock;
} ZCSPlay__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSPlay_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSPlay__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSPlayAction_Play,
        .core.name = "action",
        .core.dataTypeSpecific.enumDescFunc = ZCSPlayAction_EnumDescriptor,
        .core.number = ZCSPlay_FieldNumber_Action,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSPlay__storage_, action),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = ZCSItemType_ItemTrack,
        .core.name = "itemType",
        .core.dataTypeSpecific.enumDescFunc = ZCSItemType_EnumDescriptor,
        .core.number = ZCSPlay_FieldNumber_ItemType,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ZCSPlay__storage_, itemType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "srcId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSPlay_FieldNumber_SrcId,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ZCSPlay__storage_, srcId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "trackId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSPlay_FieldNumber_TrackId,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(ZCSPlay__storage_, trackId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "contentBlock",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContentBlock),
        .core.number = ZCSPlay_FieldNumber_ContentBlock,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(ZCSPlay__storage_, contentBlock),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSPlay class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSPlay__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSNavigation

@implementation ZCSNavigation

@dynamic hasContext, context;
@dynamic hasAction, action;
@dynamic hasOldTrackId, oldTrackId;
@dynamic hasNewTrackId, newTrackId;

typedef struct ZCSNavigation__storage_ {
  uint32_t _has_storage_[1];
  ZCSNavigation_Action action;
  ZCSContextOpenplay *context;
  NSString *oldTrackId;
  NSString *newTrackId;
} ZCSNavigation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSNavigation_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSNavigation__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSNavigation_Action_Next,
        .core.name = "action",
        .core.dataTypeSpecific.enumDescFunc = ZCSNavigation_Action_EnumDescriptor,
        .core.number = ZCSNavigation_FieldNumber_Action,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSNavigation__storage_, action),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "oldTrackId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSNavigation_FieldNumber_OldTrackId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ZCSNavigation__storage_, oldTrackId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "newTrackId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSNavigation_FieldNumber_NewTrackId,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ZCSNavigation__storage_, newTrackId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSNavigation class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSNavigation__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ZCSNavigation_Action

GPBEnumDescriptor *ZCSNavigation_Action_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Next\000Previous\000";
    static const int32_t values[] = {
        ZCSNavigation_Action_Next,
        ZCSNavigation_Action_Previous,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSNavigation_Action)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSNavigation_Action_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSNavigation_Action_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSNavigation_Action_Next:
    case ZCSNavigation_Action_Previous:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ZCSRewind

@implementation ZCSRewind

@dynamic hasContext, context;
@dynamic hasSrcType, srcType;
@dynamic hasSrcId, srcId;
@dynamic hasTrackId, trackId;
@dynamic hasStartPos, startPos;
@dynamic hasEndPos, endPos;

typedef struct ZCSRewind__storage_ {
  uint32_t _has_storage_[1];
  ZCSSrcType srcType;
  uint32_t startPos;
  uint32_t endPos;
  ZCSContextOpenplay *context;
  NSString *srcId;
  NSString *trackId;
} ZCSRewind__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSRewind_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSRewind__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSSrcType_Track,
        .core.name = "srcType",
        .core.dataTypeSpecific.enumDescFunc = ZCSSrcType_EnumDescriptor,
        .core.number = ZCSRewind_FieldNumber_SrcType,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSRewind__storage_, srcType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "srcId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSRewind_FieldNumber_SrcId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ZCSRewind__storage_, srcId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "trackId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSRewind_FieldNumber_TrackId,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ZCSRewind__storage_, trackId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "startPos",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSRewind_FieldNumber_StartPos,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(ZCSRewind__storage_, startPos),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
      {
        .defaultValue.valueUInt32 = 0U,
        .core.name = "endPos",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSRewind_FieldNumber_EndPos,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(ZCSRewind__storage_, endPos),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSRewind class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSRewind__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSVolumeChange

@implementation ZCSVolumeChange

@dynamic hasContext, context;
@dynamic hasVolumeBefore, volumeBefore;
@dynamic hasVolumeAfter, volumeAfter;

typedef struct ZCSVolumeChange__storage_ {
  uint32_t _has_storage_[1];
  uint32_t volumeBefore;
  uint32_t volumeAfter;
  ZCSContextOpenplay *context;
} ZCSVolumeChange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .number = ZCSVolumeChange_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZCSVolumeChange__storage_, context),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "volumeBefore",
        .dataTypeSpecific.className = NULL,
        .number = ZCSVolumeChange_FieldNumber_VolumeBefore,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZCSVolumeChange__storage_, volumeBefore),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "volumeAfter",
        .dataTypeSpecific.className = NULL,
        .number = ZCSVolumeChange_FieldNumber_VolumeAfter,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZCSVolumeChange__storage_, volumeAfter),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSVolumeChange class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZCSVolumeChange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSLike

@implementation ZCSLike

@dynamic hasContext, context;
@dynamic hasAction, action;
@dynamic hasItemType, itemType;
@dynamic hasSrcId, srcId;
@dynamic hasActionMenu, actionMenu;

typedef struct ZCSLike__storage_ {
  uint32_t _has_storage_[1];
  ZCSLike_LikeAction action;
  ZCSItemType itemType;
  ZCSContextOpenplay *context;
  NSString *srcId;
} ZCSLike__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSLike_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSLike__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSLike_LikeAction_Like,
        .core.name = "action",
        .core.dataTypeSpecific.enumDescFunc = ZCSLike_LikeAction_EnumDescriptor,
        .core.number = ZCSLike_FieldNumber_Action,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSLike__storage_, action),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = ZCSItemType_ItemTrack,
        .core.name = "itemType",
        .core.dataTypeSpecific.enumDescFunc = ZCSItemType_EnumDescriptor,
        .core.number = ZCSLike_FieldNumber_ItemType,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ZCSLike__storage_, itemType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "srcId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSLike_FieldNumber_SrcId,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ZCSLike__storage_, srcId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "actionMenu",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSLike_FieldNumber_ActionMenu,
        .core.hasIndex = 4,
        .core.offset = 5,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSLike class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSLike__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ZCSLike_LikeAction

GPBEnumDescriptor *ZCSLike_LikeAction_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Like\000Dislike\000";
    static const int32_t values[] = {
        ZCSLike_LikeAction_Like,
        ZCSLike_LikeAction_Dislike,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSLike_LikeAction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSLike_LikeAction_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSLike_LikeAction_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSLike_LikeAction_Like:
    case ZCSLike_LikeAction_Dislike:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ZCSShare

@implementation ZCSShare

@dynamic hasContext, context;
@dynamic hasAction, action;
@dynamic hasItemType, itemType;
@dynamic hasSrcId, srcId;
@dynamic hasContentBlock, contentBlock;
@dynamic hasActionMenu, actionMenu;

typedef struct ZCSShare__storage_ {
  uint32_t _has_storage_[1];
  ZCSShare_ShareAction action;
  ZCSItemType itemType;
  ZCSContextOpenplay *context;
  NSString *srcId;
  ZCSContentBlock *contentBlock;
} ZCSShare__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSShare_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSShare__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSShare_ShareAction_ShareButton,
        .core.name = "action",
        .core.dataTypeSpecific.enumDescFunc = ZCSShare_ShareAction_EnumDescriptor,
        .core.number = ZCSShare_FieldNumber_Action,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSShare__storage_, action),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = ZCSItemType_ItemTrack,
        .core.name = "itemType",
        .core.dataTypeSpecific.enumDescFunc = ZCSItemType_EnumDescriptor,
        .core.number = ZCSShare_FieldNumber_ItemType,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ZCSShare__storage_, itemType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "srcId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSShare_FieldNumber_SrcId,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ZCSShare__storage_, srcId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "contentBlock",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContentBlock),
        .core.number = ZCSShare_FieldNumber_ContentBlock,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(ZCSShare__storage_, contentBlock),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "actionMenu",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSShare_FieldNumber_ActionMenu,
        .core.hasIndex = 5,
        .core.offset = 6,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSShare class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSShare__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ZCSShare_ShareAction

GPBEnumDescriptor *ZCSShare_ShareAction_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "ShareButton\000Fb\000Vk\000Telegram\000Whatsapp\000Vibe"
        "r\000GetLink\000More\000";
    static const int32_t values[] = {
        ZCSShare_ShareAction_ShareButton,
        ZCSShare_ShareAction_Fb,
        ZCSShare_ShareAction_Vk,
        ZCSShare_ShareAction_Telegram,
        ZCSShare_ShareAction_Whatsapp,
        ZCSShare_ShareAction_Viber,
        ZCSShare_ShareAction_GetLink,
        ZCSShare_ShareAction_More,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSShare_ShareAction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSShare_ShareAction_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSShare_ShareAction_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSShare_ShareAction_ShareButton:
    case ZCSShare_ShareAction_Fb:
    case ZCSShare_ShareAction_Vk:
    case ZCSShare_ShareAction_Telegram:
    case ZCSShare_ShareAction_Whatsapp:
    case ZCSShare_ShareAction_Viber:
    case ZCSShare_ShareAction_GetLink:
    case ZCSShare_ShareAction_More:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ZCSShuffle

@implementation ZCSShuffle

@dynamic hasContext, context;
@dynamic hasAction, action;
@dynamic hasItemType, itemType;
@dynamic hasSrcId, srcId;
@dynamic hasTrackId, trackId;
@dynamic hasContentBlock, contentBlock;

typedef struct ZCSShuffle__storage_ {
  uint32_t _has_storage_[1];
  ZCSOnOff action;
  ZCSItemType itemType;
  ZCSContextOpenplay *context;
  NSString *srcId;
  NSString *trackId;
  ZCSContentBlock *contentBlock;
} ZCSShuffle__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSShuffle_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSShuffle__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSOnOff_On,
        .core.name = "action",
        .core.dataTypeSpecific.enumDescFunc = ZCSOnOff_EnumDescriptor,
        .core.number = ZCSShuffle_FieldNumber_Action,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSShuffle__storage_, action),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = ZCSItemType_ItemTrack,
        .core.name = "itemType",
        .core.dataTypeSpecific.enumDescFunc = ZCSItemType_EnumDescriptor,
        .core.number = ZCSShuffle_FieldNumber_ItemType,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ZCSShuffle__storage_, itemType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "srcId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSShuffle_FieldNumber_SrcId,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ZCSShuffle__storage_, srcId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "trackId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSShuffle_FieldNumber_TrackId,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(ZCSShuffle__storage_, trackId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "contentBlock",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContentBlock),
        .core.number = ZCSShuffle_FieldNumber_ContentBlock,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(ZCSShuffle__storage_, contentBlock),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSShuffle class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSShuffle__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSRepeat

@implementation ZCSRepeat

@dynamic hasContext, context;
@dynamic hasAction, action;
@dynamic hasSrcType, srcType;
@dynamic hasSrcId, srcId;
@dynamic hasTrackId, trackId;

typedef struct ZCSRepeat__storage_ {
  uint32_t _has_storage_[1];
  ZCSRepeat_RepeatAction action;
  ZCSSrcType srcType;
  ZCSContextOpenplay *context;
  NSString *srcId;
  NSString *trackId;
} ZCSRepeat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSRepeat_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSRepeat__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSRepeat_RepeatAction_Off,
        .core.name = "action",
        .core.dataTypeSpecific.enumDescFunc = ZCSRepeat_RepeatAction_EnumDescriptor,
        .core.number = ZCSRepeat_FieldNumber_Action,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSRepeat__storage_, action),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = ZCSSrcType_Track,
        .core.name = "srcType",
        .core.dataTypeSpecific.enumDescFunc = ZCSSrcType_EnumDescriptor,
        .core.number = ZCSRepeat_FieldNumber_SrcType,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ZCSRepeat__storage_, srcType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "srcId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSRepeat_FieldNumber_SrcId,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ZCSRepeat__storage_, srcId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "trackId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSRepeat_FieldNumber_TrackId,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(ZCSRepeat__storage_, trackId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSRepeat class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSRepeat__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ZCSRepeat_RepeatAction

GPBEnumDescriptor *ZCSRepeat_RepeatAction_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Off\000Track\000Object\000";
    static const int32_t values[] = {
        ZCSRepeat_RepeatAction_Off,
        ZCSRepeat_RepeatAction_Track,
        ZCSRepeat_RepeatAction_Object,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSRepeat_RepeatAction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSRepeat_RepeatAction_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSRepeat_RepeatAction_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSRepeat_RepeatAction_Off:
    case ZCSRepeat_RepeatAction_Track:
    case ZCSRepeat_RepeatAction_Object:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ZCSDownload

@implementation ZCSDownload

@dynamic hasContext, context;
@dynamic hasAction, action;
@dynamic hasItemType, itemType;
@dynamic hasSrcId, srcId;
@dynamic hasActionMenu, actionMenu;

typedef struct ZCSDownload__storage_ {
  uint32_t _has_storage_[1];
  ZCSDownload_DownloadAction action;
  ZCSItemType itemType;
  ZCSContextOpenplay *context;
  NSString *srcId;
} ZCSDownload__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSDownload_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSDownload__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSDownload_DownloadAction_Add,
        .core.name = "action",
        .core.dataTypeSpecific.enumDescFunc = ZCSDownload_DownloadAction_EnumDescriptor,
        .core.number = ZCSDownload_FieldNumber_Action,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSDownload__storage_, action),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = ZCSItemType_ItemTrack,
        .core.name = "itemType",
        .core.dataTypeSpecific.enumDescFunc = ZCSItemType_EnumDescriptor,
        .core.number = ZCSDownload_FieldNumber_ItemType,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ZCSDownload__storage_, itemType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "srcId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSDownload_FieldNumber_SrcId,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ZCSDownload__storage_, srcId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "actionMenu",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSDownload_FieldNumber_ActionMenu,
        .core.hasIndex = 4,
        .core.offset = 5,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSDownload class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSDownload__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ZCSDownload_DownloadAction

GPBEnumDescriptor *ZCSDownload_DownloadAction_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Add\000Delete\000";
    static const int32_t values[] = {
        ZCSDownload_DownloadAction_Add,
        ZCSDownload_DownloadAction_Delete,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSDownload_DownloadAction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSDownload_DownloadAction_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSDownload_DownloadAction_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSDownload_DownloadAction_Add:
    case ZCSDownload_DownloadAction_Delete:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ZCSAddToPlaylist

@implementation ZCSAddToPlaylist

@dynamic hasContext, context;
@dynamic hasItemType, itemType;
@dynamic hasSrcId, srcId;
@dynamic hasActionMenu, actionMenu;

typedef struct ZCSAddToPlaylist__storage_ {
  uint32_t _has_storage_[1];
  ZCSItemType itemType;
  ZCSContextOpenplay *context;
  NSString *srcId;
} ZCSAddToPlaylist__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSAddToPlaylist_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSAddToPlaylist__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSItemType_ItemTrack,
        .core.name = "itemType",
        .core.dataTypeSpecific.enumDescFunc = ZCSItemType_EnumDescriptor,
        .core.number = ZCSAddToPlaylist_FieldNumber_ItemType,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSAddToPlaylist__storage_, itemType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "srcId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSAddToPlaylist_FieldNumber_SrcId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ZCSAddToPlaylist__storage_, srcId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "actionMenu",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSAddToPlaylist_FieldNumber_ActionMenu,
        .core.hasIndex = 3,
        .core.offset = 4,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSAddToPlaylist class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSAddToPlaylist__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSAddToQueue

@implementation ZCSAddToQueue

@dynamic hasContext, context;
@dynamic hasItemType, itemType;
@dynamic hasSrcId, srcId;
@dynamic hasActionMenu, actionMenu;

typedef struct ZCSAddToQueue__storage_ {
  uint32_t _has_storage_[1];
  ZCSItemType itemType;
  ZCSContextOpenplay *context;
  NSString *srcId;
} ZCSAddToQueue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSAddToQueue_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSAddToQueue__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSItemType_ItemTrack,
        .core.name = "itemType",
        .core.dataTypeSpecific.enumDescFunc = ZCSItemType_EnumDescriptor,
        .core.number = ZCSAddToQueue_FieldNumber_ItemType,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSAddToQueue__storage_, itemType),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "srcId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSAddToQueue_FieldNumber_SrcId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ZCSAddToQueue__storage_, srcId),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "actionMenu",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSAddToQueue_FieldNumber_ActionMenu,
        .core.hasIndex = 3,
        .core.offset = 4,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSAddToQueue class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSAddToQueue__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSGoToArtistPage

@implementation ZCSGoToArtistPage

@dynamic hasContext, context;
@dynamic hasArtistId, artistId;
@dynamic hasItem, item;
@dynamic hasActionMenu, actionMenu;

typedef struct ZCSGoToArtistPage__storage_ {
  uint32_t _has_storage_[1];
  ZCSContextOpenplay *context;
  NSString *artistId;
  ZCSItem *item;
} ZCSGoToArtistPage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .number = ZCSGoToArtistPage_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZCSGoToArtistPage__storage_, context),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "artistId",
        .dataTypeSpecific.className = NULL,
        .number = ZCSGoToArtistPage_FieldNumber_ArtistId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZCSGoToArtistPage__storage_, artistId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "item",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSItem),
        .number = ZCSGoToArtistPage_FieldNumber_Item,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZCSGoToArtistPage__storage_, item),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "actionMenu",
        .dataTypeSpecific.className = NULL,
        .number = ZCSGoToArtistPage_FieldNumber_ActionMenu,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSGoToArtistPage class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZCSGoToArtistPage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSGoToReleasePage

@implementation ZCSGoToReleasePage

@dynamic hasContext, context;
@dynamic hasReleaseId, releaseId;
@dynamic hasItem, item;
@dynamic hasActionMenu, actionMenu;

typedef struct ZCSGoToReleasePage__storage_ {
  uint32_t _has_storage_[1];
  ZCSContextOpenplay *context;
  NSString *releaseId;
  ZCSItem *item;
} ZCSGoToReleasePage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .number = ZCSGoToReleasePage_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZCSGoToReleasePage__storage_, context),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "releaseId",
        .dataTypeSpecific.className = NULL,
        .number = ZCSGoToReleasePage_FieldNumber_ReleaseId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZCSGoToReleasePage__storage_, releaseId),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "item",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSItem),
        .number = ZCSGoToReleasePage_FieldNumber_Item,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ZCSGoToReleasePage__storage_, item),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "actionMenu",
        .dataTypeSpecific.className = NULL,
        .number = ZCSGoToReleasePage_FieldNumber_ActionMenu,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSGoToReleasePage class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZCSGoToReleasePage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSOfflineMode

@implementation ZCSOfflineMode

@dynamic hasContext, context;
@dynamic hasAction, action;

typedef struct ZCSOfflineMode__storage_ {
  uint32_t _has_storage_[1];
  ZCSOnOff action;
  ZCSContextOpenplay *context;
} ZCSOfflineMode__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSOfflineMode_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSOfflineMode__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSOnOff_On,
        .core.name = "action",
        .core.dataTypeSpecific.enumDescFunc = ZCSOnOff_EnumDescriptor,
        .core.number = ZCSOfflineMode_FieldNumber_Action,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSOfflineMode__storage_, action),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSOfflineMode class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSOfflineMode__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSUse3GLTE

@implementation ZCSUse3GLTE

@dynamic hasContext, context;
@dynamic hasAction, action;

typedef struct ZCSUse3GLTE__storage_ {
  uint32_t _has_storage_[1];
  ZCSOnOff action;
  ZCSContextOpenplay *context;
} ZCSUse3GLTE__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSUse3GLTE_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSUse3GLTE__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSOnOff_On,
        .core.name = "action",
        .core.dataTypeSpecific.enumDescFunc = ZCSOnOff_EnumDescriptor,
        .core.number = ZCSUse3GLTE_FieldNumber_Action,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSUse3GLTE__storage_, action),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSUse3GLTE class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSUse3GLTE__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSHighQuality

@implementation ZCSHighQuality

@dynamic hasContext, context;
@dynamic hasAction, action;

typedef struct ZCSHighQuality__storage_ {
  uint32_t _has_storage_[1];
  ZCSOnOff action;
  ZCSContextOpenplay *context;
} ZCSHighQuality__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSHighQuality_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSHighQuality__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSOnOff_On,
        .core.name = "action",
        .core.dataTypeSpecific.enumDescFunc = ZCSOnOff_EnumDescriptor,
        .core.number = ZCSHighQuality_FieldNumber_Action,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSHighQuality__storage_, action),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSHighQuality class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSHighQuality__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSUnlimitedSkippings

@implementation ZCSUnlimitedSkippings

@dynamic hasContext, context;

typedef struct ZCSUnlimitedSkippings__storage_ {
  uint32_t _has_storage_[1];
  ZCSContextOpenplay *context;
} ZCSUnlimitedSkippings__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .number = ZCSUnlimitedSkippings_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZCSUnlimitedSkippings__storage_, context),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSUnlimitedSkippings class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZCSUnlimitedSkippings__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSNoAds

@implementation ZCSNoAds

@dynamic hasContext, context;

typedef struct ZCSNoAds__storage_ {
  uint32_t _has_storage_[1];
  ZCSContextOpenplay *context;
} ZCSNoAds__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .number = ZCSNoAds_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZCSNoAds__storage_, context),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSNoAds class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZCSNoAds__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSAddItunesLibrary

@implementation ZCSAddItunesLibrary

@dynamic hasContext, context;
@dynamic hasAction, action;

typedef struct ZCSAddItunesLibrary__storage_ {
  uint32_t _has_storage_[1];
  ZCSOnOff action;
  ZCSContextOpenplay *context;
} ZCSAddItunesLibrary__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSAddItunesLibrary_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSAddItunesLibrary__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSOnOff_On,
        .core.name = "action",
        .core.dataTypeSpecific.enumDescFunc = ZCSOnOff_EnumDescriptor,
        .core.number = ZCSAddItunesLibrary_FieldNumber_Action,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSAddItunesLibrary__storage_, action),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSAddItunesLibrary class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSAddItunesLibrary__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSHistoryButton

@implementation ZCSHistoryButton

@dynamic hasContext, context;

typedef struct ZCSHistoryButton__storage_ {
  uint32_t _has_storage_[1];
  ZCSContextOpenplay *context;
} ZCSHistoryButton__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .number = ZCSHistoryButton_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZCSHistoryButton__storage_, context),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSHistoryButton class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZCSHistoryButton__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSSearchActivated

@implementation ZCSSearchActivated

@dynamic hasContext, context;
@dynamic hasQuery, query;

typedef struct ZCSSearchActivated__storage_ {
  uint32_t _has_storage_[1];
  ZCSContextOpenplay *context;
  NSString *query;
} ZCSSearchActivated__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .number = ZCSSearchActivated_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZCSSearchActivated__storage_, context),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = ZCSSearchActivated_FieldNumber_Query,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZCSSearchActivated__storage_, query),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSSearchActivated class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZCSSearchActivated__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSSponsorPick

@implementation ZCSSponsorPick

@dynamic hasContext, context;
@dynamic hasSponsorName, sponsorName;

typedef struct ZCSSponsorPick__storage_ {
  uint32_t _has_storage_[1];
  ZCSContextOpenplay *context;
  NSString *sponsorName;
} ZCSSponsorPick__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .number = ZCSSponsorPick_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZCSSponsorPick__storage_, context),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sponsorName",
        .dataTypeSpecific.className = NULL,
        .number = ZCSSponsorPick_FieldNumber_SponsorName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZCSSponsorPick__storage_, sponsorName),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSSponsorPick class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZCSSponsorPick__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSSponsorOffers

@implementation ZCSSponsorOffers

@dynamic hasContext, context;

typedef struct ZCSSponsorOffers__storage_ {
  uint32_t _has_storage_[1];
  ZCSContextOpenplay *context;
} ZCSSponsorOffers__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .number = ZCSSponsorOffers_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZCSSponsorOffers__storage_, context),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSSponsorOffers class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZCSSponsorOffers__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSPremiumSubscriptions

@implementation ZCSPremiumSubscriptions

@dynamic hasContext, context;

typedef struct ZCSPremiumSubscriptions__storage_ {
  uint32_t _has_storage_[1];
  ZCSContextOpenplay *context;
} ZCSPremiumSubscriptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .number = ZCSPremiumSubscriptions_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZCSPremiumSubscriptions__storage_, context),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSPremiumSubscriptions class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZCSPremiumSubscriptions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSProfileClicked

@implementation ZCSProfileClicked

@dynamic hasContext, context;
@dynamic hasAction, action;

typedef struct ZCSProfileClicked__storage_ {
  uint32_t _has_storage_[1];
  ZCSProfileClicked_ActionButton action;
  ZCSContextOpenplay *context;
} ZCSProfileClicked__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSProfileClicked_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSProfileClicked__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSProfileClicked_ActionButton_Profile,
        .core.name = "action",
        .core.dataTypeSpecific.enumDescFunc = ZCSProfileClicked_ActionButton_EnumDescriptor,
        .core.number = ZCSProfileClicked_FieldNumber_Action,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSProfileClicked__storage_, action),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSProfileClicked class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSProfileClicked__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ZCSProfileClicked_ActionButton

GPBEnumDescriptor *ZCSProfileClicked_ActionButton_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Profile\000Country\000StorageSettings\000HelpSupp"
        "ort\000LicenseInformation\000Acknowledgements\000"
        "PremiumFeatures\000TermsOfUse\000PrivacyPolicy"
        "\000";
    static const int32_t values[] = {
        ZCSProfileClicked_ActionButton_Profile,
        ZCSProfileClicked_ActionButton_Country,
        ZCSProfileClicked_ActionButton_StorageSettings,
        ZCSProfileClicked_ActionButton_HelpSupport,
        ZCSProfileClicked_ActionButton_LicenseInformation,
        ZCSProfileClicked_ActionButton_Acknowledgements,
        ZCSProfileClicked_ActionButton_PremiumFeatures,
        ZCSProfileClicked_ActionButton_TermsOfUse,
        ZCSProfileClicked_ActionButton_PrivacyPolicy,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSProfileClicked_ActionButton)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSProfileClicked_ActionButton_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSProfileClicked_ActionButton_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSProfileClicked_ActionButton_Profile:
    case ZCSProfileClicked_ActionButton_Country:
    case ZCSProfileClicked_ActionButton_StorageSettings:
    case ZCSProfileClicked_ActionButton_HelpSupport:
    case ZCSProfileClicked_ActionButton_LicenseInformation:
    case ZCSProfileClicked_ActionButton_Acknowledgements:
    case ZCSProfileClicked_ActionButton_PremiumFeatures:
    case ZCSProfileClicked_ActionButton_TermsOfUse:
    case ZCSProfileClicked_ActionButton_PrivacyPolicy:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ZCSProfileChanged

@implementation ZCSProfileChanged

@dynamic hasContext, context;
@dynamic actionArray, actionArray_Count;

typedef struct ZCSProfileChanged__storage_ {
  uint32_t _has_storage_[1];
  ZCSContextOpenplay *context;
  GPBEnumArray *actionArray;
} ZCSProfileChanged__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .number = ZCSProfileChanged_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZCSProfileChanged__storage_, context),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "actionArray",
        .dataTypeSpecific.enumDescFunc = ZCSProfileChanged_ChangeAction_EnumDescriptor,
        .number = ZCSProfileChanged_FieldNumber_ActionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZCSProfileChanged__storage_, actionArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSProfileChanged class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZCSProfileChanged__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ZCSProfileChanged_ChangeAction

GPBEnumDescriptor *ZCSProfileChanged_ChangeAction_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Photo\000Name\000Fb\000Vk\000Phone\000Email\000Password\000";
    static const int32_t values[] = {
        ZCSProfileChanged_ChangeAction_Photo,
        ZCSProfileChanged_ChangeAction_Name,
        ZCSProfileChanged_ChangeAction_Fb,
        ZCSProfileChanged_ChangeAction_Vk,
        ZCSProfileChanged_ChangeAction_Phone,
        ZCSProfileChanged_ChangeAction_Email,
        ZCSProfileChanged_ChangeAction_Password,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ZCSProfileChanged_ChangeAction)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ZCSProfileChanged_ChangeAction_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ZCSProfileChanged_ChangeAction_IsValidValue(int32_t value__) {
  switch (value__) {
    case ZCSProfileChanged_ChangeAction_Photo:
    case ZCSProfileChanged_ChangeAction_Name:
    case ZCSProfileChanged_ChangeAction_Fb:
    case ZCSProfileChanged_ChangeAction_Vk:
    case ZCSProfileChanged_ChangeAction_Phone:
    case ZCSProfileChanged_ChangeAction_Email:
    case ZCSProfileChanged_ChangeAction_Password:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ZCSPushOpened

@implementation ZCSPushOpened

@dynamic hasContext, context;
@dynamic hasSrcType, srcType;
@dynamic hasSrcId, srcId;
@dynamic hasDestinationURL, destinationURL;
@dynamic hasAlert, alert;

typedef struct ZCSPushOpened__storage_ {
  uint32_t _has_storage_[1];
  ZCSSrcType srcType;
  ZCSContextOpenplay *context;
  NSString *srcId;
  NSString *destinationURL;
  NSString *alert;
} ZCSPushOpened__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSPushOpened_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSPushOpened__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSSrcType_Track,
        .core.name = "srcType",
        .core.dataTypeSpecific.enumDescFunc = ZCSSrcType_EnumDescriptor,
        .core.number = ZCSPushOpened_FieldNumber_SrcType,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSPushOpened__storage_, srcType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "srcId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSPushOpened_FieldNumber_SrcId,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ZCSPushOpened__storage_, srcId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "destinationURL",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSPushOpened_FieldNumber_DestinationURL,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(ZCSPushOpened__storage_, destinationURL),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "alert",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ZCSPushOpened_FieldNumber_Alert,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(ZCSPushOpened__storage_, alert),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSPushOpened class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSPushOpened__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\013\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSLogout

@implementation ZCSLogout

@dynamic hasContext, context;

typedef struct ZCSLogout__storage_ {
  uint32_t _has_storage_[1];
  ZCSContextOpenplay *context;
} ZCSLogout__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .number = ZCSLogout_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZCSLogout__storage_, context),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSLogout class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZCSLogout__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSStorageClear

@implementation ZCSStorageClear

@dynamic hasContext, context;

typedef struct ZCSStorageClear__storage_ {
  uint32_t _has_storage_[1];
  ZCSContextOpenplay *context;
} ZCSStorageClear__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .number = ZCSStorageClear_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZCSStorageClear__storage_, context),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSStorageClear class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZCSStorageClear__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSSmartCaching

@implementation ZCSSmartCaching

@dynamic hasContext, context;
@dynamic hasAction, action;

typedef struct ZCSSmartCaching__storage_ {
  uint32_t _has_storage_[1];
  ZCSOnOff action;
  ZCSContextOpenplay *context;
} ZCSSmartCaching__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSSmartCaching_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSSmartCaching__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSOnOff_On,
        .core.name = "action",
        .core.dataTypeSpecific.enumDescFunc = ZCSOnOff_EnumDescriptor,
        .core.number = ZCSSmartCaching_FieldNumber_Action,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSSmartCaching__storage_, action),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSSmartCaching class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSSmartCaching__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSPreCaching

@implementation ZCSPreCaching

@dynamic hasContext, context;
@dynamic hasAction, action;

typedef struct ZCSPreCaching__storage_ {
  uint32_t _has_storage_[1];
  ZCSOnOff action;
  ZCSContextOpenplay *context;
} ZCSPreCaching__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueMessage = nil,
        .core.name = "context",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .core.number = ZCSPreCaching_FieldNumber_Context,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ZCSPreCaching__storage_, context),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueEnum = ZCSOnOff_On,
        .core.name = "action",
        .core.dataTypeSpecific.enumDescFunc = ZCSOnOff_EnumDescriptor,
        .core.number = ZCSPreCaching_FieldNumber_Action,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ZCSPreCaching__storage_, action),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSPreCaching class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ZCSPreCaching__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSCountryChange

@implementation ZCSCountryChange

@dynamic hasContext, context;
@dynamic hasCountry, country;

typedef struct ZCSCountryChange__storage_ {
  uint32_t _has_storage_[1];
  ZCSContextOpenplay *context;
  NSString *country;
} ZCSCountryChange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .number = ZCSCountryChange_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZCSCountryChange__storage_, context),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "country",
        .dataTypeSpecific.className = NULL,
        .number = ZCSCountryChange_FieldNumber_Country,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZCSCountryChange__storage_, country),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSCountryChange class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZCSCountryChange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSRateUs

@implementation ZCSRateUs

@dynamic hasContext, context;
@dynamic hasRating, rating;

typedef struct ZCSRateUs__storage_ {
  uint32_t _has_storage_[1];
  uint32_t rating;
  ZCSContextOpenplay *context;
} ZCSRateUs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSContextOpenplay),
        .number = ZCSRateUs_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZCSRateUs__storage_, context),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rating",
        .dataTypeSpecific.className = NULL,
        .number = ZCSRateUs_FieldNumber_Rating,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ZCSRateUs__storage_, rating),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSRateUs class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZCSRateUs__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ZCSEvent

@implementation ZCSEvent

@dynamic eventOneOfCase;
@dynamic playevent;
@dynamic appOpened;
@dynamic authenticationInitiated;
@dynamic authenticationSuccessful;
@dynamic authenticationFailed;
@dynamic subscriptionInitiated;
@dynamic subscriptionSuccessful;
@dynamic subscriptionFailed;
@dynamic actionKitShown;
@dynamic actionKitClicked;
@dynamic screenShown;
@dynamic contentBlockClick;
@dynamic play;
@dynamic navigation;
@dynamic rewind;
@dynamic volumeChange;
@dynamic like;
@dynamic share;
@dynamic shuffle;
@dynamic repeat;
@dynamic download;
@dynamic addToPlaylist;
@dynamic addToQueue;
@dynamic goToArtistPage;
@dynamic goToReleasePage;
@dynamic offlineMode;
@dynamic use3GLte;
@dynamic highQuality;
@dynamic addItunesLibrary;
@dynamic profileClicked;
@dynamic historyButton;
@dynamic searchActivated;
@dynamic storageClear;
@dynamic countryChange;
@dynamic sponsorPick;
@dynamic sponsorOffers;
@dynamic premiumSubscriptions;
@dynamic pushOpened;
@dynamic appResume;
@dynamic logout;
@dynamic actionKitLoaded;
@dynamic actionKitRequested;
@dynamic unlimitedSkippings;
@dynamic noAds;
@dynamic smartCaching;
@dynamic preCaching;
@dynamic profileChanged;
@dynamic rateUs;

typedef struct ZCSEvent__storage_ {
  uint32_t _has_storage_[2];
  ZCSPlayevent *playevent;
  ZCSAppOpened *appOpened;
  ZCSAuthenticationInitiated *authenticationInitiated;
  ZCSAuthenticationSuccessful *authenticationSuccessful;
  ZCSAuthenticationFailed *authenticationFailed;
  ZCSSubscriptionInitiated *subscriptionInitiated;
  ZCSSubscriptionSuccessful *subscriptionSuccessful;
  ZCSSubscriptionFailed *subscriptionFailed;
  ZCSActionKitShown *actionKitShown;
  ZCSActionKitClicked *actionKitClicked;
  ZCSScreenShown *screenShown;
  ZCSContentBlockClick *contentBlockClick;
  ZCSPlay *play;
  ZCSNavigation *navigation;
  ZCSRewind *rewind;
  ZCSVolumeChange *volumeChange;
  ZCSLike *like;
  ZCSShare *share;
  ZCSShuffle *shuffle;
  ZCSRepeat *repeat;
  ZCSDownload *download;
  ZCSAddToPlaylist *addToPlaylist;
  ZCSAddToQueue *addToQueue;
  ZCSGoToArtistPage *goToArtistPage;
  ZCSGoToReleasePage *goToReleasePage;
  ZCSOfflineMode *offlineMode;
  ZCSUse3GLTE *use3GLte;
  ZCSHighQuality *highQuality;
  ZCSAddItunesLibrary *addItunesLibrary;
  ZCSProfileClicked *profileClicked;
  ZCSHistoryButton *historyButton;
  ZCSSearchActivated *searchActivated;
  ZCSStorageClear *storageClear;
  ZCSCountryChange *countryChange;
  ZCSSponsorPick *sponsorPick;
  ZCSSponsorOffers *sponsorOffers;
  ZCSPremiumSubscriptions *premiumSubscriptions;
  ZCSPushOpened *pushOpened;
  ZCSAppResume *appResume;
  ZCSLogout *logout;
  ZCSActionKitLoaded *actionKitLoaded;
  ZCSActionKitRequested *actionKitRequested;
  ZCSUnlimitedSkippings *unlimitedSkippings;
  ZCSNoAds *noAds;
  ZCSSmartCaching *smartCaching;
  ZCSPreCaching *preCaching;
  ZCSProfileChanged *profileChanged;
  ZCSRateUs *rateUs;
} ZCSEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "playevent",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSPlayevent),
        .number = ZCSEvent_FieldNumber_Playevent,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, playevent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "appOpened",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSAppOpened),
        .number = ZCSEvent_FieldNumber_AppOpened,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, appOpened),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "authenticationInitiated",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSAuthenticationInitiated),
        .number = ZCSEvent_FieldNumber_AuthenticationInitiated,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, authenticationInitiated),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "authenticationSuccessful",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSAuthenticationSuccessful),
        .number = ZCSEvent_FieldNumber_AuthenticationSuccessful,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, authenticationSuccessful),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "authenticationFailed",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSAuthenticationFailed),
        .number = ZCSEvent_FieldNumber_AuthenticationFailed,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, authenticationFailed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "subscriptionInitiated",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSSubscriptionInitiated),
        .number = ZCSEvent_FieldNumber_SubscriptionInitiated,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, subscriptionInitiated),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "subscriptionSuccessful",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSSubscriptionSuccessful),
        .number = ZCSEvent_FieldNumber_SubscriptionSuccessful,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, subscriptionSuccessful),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "subscriptionFailed",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSSubscriptionFailed),
        .number = ZCSEvent_FieldNumber_SubscriptionFailed,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, subscriptionFailed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "actionKitShown",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSActionKitShown),
        .number = ZCSEvent_FieldNumber_ActionKitShown,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, actionKitShown),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "actionKitClicked",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSActionKitClicked),
        .number = ZCSEvent_FieldNumber_ActionKitClicked,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, actionKitClicked),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "screenShown",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSScreenShown),
        .number = ZCSEvent_FieldNumber_ScreenShown,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, screenShown),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contentBlockClick",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSContentBlockClick),
        .number = ZCSEvent_FieldNumber_ContentBlockClick,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, contentBlockClick),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "play",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSPlay),
        .number = ZCSEvent_FieldNumber_Play,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, play),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "navigation",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSNavigation),
        .number = ZCSEvent_FieldNumber_Navigation,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, navigation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rewind",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSRewind),
        .number = ZCSEvent_FieldNumber_Rewind,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, rewind),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "volumeChange",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSVolumeChange),
        .number = ZCSEvent_FieldNumber_VolumeChange,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, volumeChange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "like",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSLike),
        .number = ZCSEvent_FieldNumber_Like,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, like),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "share",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSShare),
        .number = ZCSEvent_FieldNumber_Share,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, share),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shuffle",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSShuffle),
        .number = ZCSEvent_FieldNumber_Shuffle,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, shuffle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "repeat",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSRepeat),
        .number = ZCSEvent_FieldNumber_Repeat,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, repeat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "download",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSDownload),
        .number = ZCSEvent_FieldNumber_Download,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, download),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "addToPlaylist",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSAddToPlaylist),
        .number = ZCSEvent_FieldNumber_AddToPlaylist,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, addToPlaylist),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "addToQueue",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSAddToQueue),
        .number = ZCSEvent_FieldNumber_AddToQueue,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, addToQueue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "goToArtistPage",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSGoToArtistPage),
        .number = ZCSEvent_FieldNumber_GoToArtistPage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, goToArtistPage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "goToReleasePage",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSGoToReleasePage),
        .number = ZCSEvent_FieldNumber_GoToReleasePage,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, goToReleasePage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "offlineMode",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSOfflineMode),
        .number = ZCSEvent_FieldNumber_OfflineMode,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, offlineMode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "use3GLte",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSUse3GLTE),
        .number = ZCSEvent_FieldNumber_Use3GLte,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, use3GLte),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "highQuality",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSHighQuality),
        .number = ZCSEvent_FieldNumber_HighQuality,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, highQuality),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "addItunesLibrary",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSAddItunesLibrary),
        .number = ZCSEvent_FieldNumber_AddItunesLibrary,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, addItunesLibrary),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "profileClicked",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSProfileClicked),
        .number = ZCSEvent_FieldNumber_ProfileClicked,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, profileClicked),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "historyButton",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSHistoryButton),
        .number = ZCSEvent_FieldNumber_HistoryButton,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, historyButton),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "searchActivated",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSSearchActivated),
        .number = ZCSEvent_FieldNumber_SearchActivated,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, searchActivated),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "storageClear",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSStorageClear),
        .number = ZCSEvent_FieldNumber_StorageClear,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, storageClear),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "countryChange",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSCountryChange),
        .number = ZCSEvent_FieldNumber_CountryChange,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, countryChange),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sponsorPick",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSSponsorPick),
        .number = ZCSEvent_FieldNumber_SponsorPick,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, sponsorPick),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sponsorOffers",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSSponsorOffers),
        .number = ZCSEvent_FieldNumber_SponsorOffers,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, sponsorOffers),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "premiumSubscriptions",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSPremiumSubscriptions),
        .number = ZCSEvent_FieldNumber_PremiumSubscriptions,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, premiumSubscriptions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pushOpened",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSPushOpened),
        .number = ZCSEvent_FieldNumber_PushOpened,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, pushOpened),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "appResume",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSAppResume),
        .number = ZCSEvent_FieldNumber_AppResume,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, appResume),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "logout",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSLogout),
        .number = ZCSEvent_FieldNumber_Logout,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, logout),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "actionKitLoaded",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSActionKitLoaded),
        .number = ZCSEvent_FieldNumber_ActionKitLoaded,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, actionKitLoaded),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "actionKitRequested",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSActionKitRequested),
        .number = ZCSEvent_FieldNumber_ActionKitRequested,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, actionKitRequested),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unlimitedSkippings",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSUnlimitedSkippings),
        .number = ZCSEvent_FieldNumber_UnlimitedSkippings,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, unlimitedSkippings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "noAds",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSNoAds),
        .number = ZCSEvent_FieldNumber_NoAds,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, noAds),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "smartCaching",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSSmartCaching),
        .number = ZCSEvent_FieldNumber_SmartCaching,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, smartCaching),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "preCaching",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSPreCaching),
        .number = ZCSEvent_FieldNumber_PreCaching,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, preCaching),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "profileChanged",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSProfileChanged),
        .number = ZCSEvent_FieldNumber_ProfileChanged,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, profileChanged),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rateUs",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSRateUs),
        .number = ZCSEvent_FieldNumber_RateUs,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ZCSEvent__storage_, rateUs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSEvent class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZCSEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "event",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\033\003\201!\243\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ZCSEvent_ClearEventOneOfCase(ZCSEvent *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - ZCSEventPackage

@implementation ZCSEventPackage

@dynamic eventsArray, eventsArray_Count;
@dynamic hasSendTimeUtc, sendTimeUtc;

typedef struct ZCSEventPackage__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *eventsArray;
  NSString *sendTimeUtc;
} ZCSEventPackage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eventsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ZCSEvent),
        .number = ZCSEventPackage_FieldNumber_EventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ZCSEventPackage__storage_, eventsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sendTimeUtc",
        .dataTypeSpecific.className = NULL,
        .number = ZCSEventPackage_FieldNumber_SendTimeUtc,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ZCSEventPackage__storage_, sendTimeUtc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ZCSEventPackage class]
                                     rootClass:[ZCSMainRoot class]
                                          file:ZCSMainRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ZCSEventPackage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
